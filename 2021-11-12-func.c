// Функции и области видимости

#include<stdio.h>
#include<stdlib.h>
#define N 10

// Место для объявления (declaration) глобальных переменных
int X, Y;
int ARR[N];

/* Глобальные переменные:
- доступны всем функциям (из этого файла)
- место под них зарезервировано в бинарном файле (а он подгружается в память непосредственно перед запуском программы) => 
	- изначально = 0
	- размер определен во время компиляции
	- лежат недалеко от кода
	- срок их жизни ограничен сроком жизни программы
*/

// Описание функций
// тип_возвращаемого_значения имя_функции(тип_аргумента сам_фргумент);
void func_ARR(){	// функция без аргументов и не возвращает значение
	ARR[0] = 9;
	// это будет корректно
	// т.к. глобальные переменные доступны из всех функций
	return;
}
void func_print(int a){	// не возвращает значение, один аргумент типа int
	printf("In func_print: argument = %d\n", a);
	// a = 0; ! а вот так делать не надо ! во-первых, когда функция отработает, это значение будет потеряно
	// а во-вторых, хороший тон, не изменять 
	return;
}
double func_mul(double a, double b){	// 2 аргумента, и возвращаемое значение типа double
	return a * b;
}
int func_sum(int a, int b){
	// Место для создания локальных переменных
	int c;
	c = a + b;
	return c;
}
/* Локальные переменные:
- существуют только внутри той функции, в которой объявлены
- место под них зарезервировано в на стеке (см. стек вызовов функций) => 
	- могут содержать любой мусор
	- существуют только пора функция работает
	- если запускать вызовы функции рекурсивно, то каждый раз это будет разные переменные
*/

/* Аргументы
- при вызове функции, в нее в передается КОПИЯ ЗНАЧЕНИЯ аргумента
	- аргументы, как и локальные переменные, существуют только пока работает функция
*/

// Это еще называется "передача аргумента по значению"
void func_print_adr(int a){
	printf("In func_print_adr: argument = %d has address %p\n", a, &a);
	// изменять a здесь было бы бессмысленно (это значение будет потеряно, как только функция завершится), и вообще, плохой тон
	return;
}
// похоже на printf("%d", a);

// Если надо внутри функции изменять какую-то внешнюю переменную, то она должна быть либо глобальной,
// либо в функцию в качестве аргумента надо передать ее адрес (указатель на нее)
// Это еще называется "передача аргумента по указателю"
void func_change(int * p){
	*p  = 5;
	// зная указатель на переменную (ее адрес) можем изменить значение переменной, на которую он указывает
	return;
}
// похоже на scanf("%d", &a);


// Пример, обращение к массиву по указателю
int find_p_i(int *p, int i){
	printf("In find_p_i: P[%d] = %d\n", i, p[i]);
	p[0] = 8; // так тоже можно, т.к. мы обращаемся к памяти, используя указатель p
	return p[i];
}


// Вызов функции
int main(){

	func_ARR(); // функция без аргументов и не возвращает значение
	printf("In main: ARR[0] = %d\n", ARR[0]);
	// т.к. глобальные переменные доступны из всех функций

	int x = 7, z = 0;
	printf("In main: z = %d\n", z);
	// при вызове функции, в нее в передается КОПИЯ ЗНАЧЕНИЯ аргумента
	z = func_sum(x, 6);
	// вызываем функцию по имени
	// если функция что-то возвращает, это что-то надо записать в переменную и проанализировать
	printf("In main: z = %d\n", z);

	// при вызове функции, в нее в передается КОПИЯ ЗНАЧЕНИЯ аргумента
	func_print_adr(z);
	printf("In main: local variable z = %d has address %p\n", z, &z);
	// Пример показывает, что z - аргумент func_print_adr и z - локальная переменная main - это разные вещи
	
	// изменить переменную z, используя "передачу значения в функцию по указателю"
	func_change(&z);
	printf("In main: z = %d\n", z);
	// при вызове функции, в нее в по-прежнему передается КОПИЯ ЗНАЧЕНИЯ аргумента
	// но сам аргумент в данном случае, это указатель на переменную z
	// то есть, мы передали в функцию КОПИЮ АДРЕСА переменной z
	// а зная адрес переменной (имея указатель на нее) можем внутри функции изменять значение переменной z

	// такой же пример для x
	int *p; // зарезервировали память под указатель на x\n
	p = &x; // положили туда адрес x, теперь p - указатель на x
	// вызовем функцию
	func_change(p);
	printf("In main: x = %d\n", x);
	// все тоже самое, что и в предыдущем примере
	
	
	/*
	Динамическое выделение памяти
		- выделяется на куче ("heap" - термин в ОС)
		- живет пока, не будет вызвана free(p);
		- доступна всем, кто имеет на нее указатель
	*/
	// выделили память динамически
	int n = 10;
	int *q = (int *)malloc(sizeof(int) * n);
	
	// передали указатель на нее в функцию
	z = find_p_i(p, 4);
	printf("In main: p[0] = %d\n", p[0]); // эта ячейка была изменена при работе find_p_i 
	
	free(q);

	return 0;
}
