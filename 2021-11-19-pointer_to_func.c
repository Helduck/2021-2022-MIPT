#include<stdio.h>
#include<stdlib.h>

// Указатель на функцию - адрес начала кода этой ф-ции в памяти

////////////////////////////////////////////////////////////////////////////////////////////////////
// Пример 1 (вызов ф-ции по указателю)

void func(){
	printf("***");
}
// функция

int main(){

	void(*p)();	// создали указатель на функцию (нет аргументов и возвращаемого значения)
	p = &func;	// положили в указатель адрес функции, заметьте, без скобок
	p();	// вызвали функцию по указателю

	return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Пример 2 (ф-ция, которая принимает другую ф-цию в качестве аргумента)

int comp(int * a, int * b){
	return *a - *b;
}

int main(){
	int i, n;
	scanf("%d", &n);
	int *q = (int *)malloc(sizeof(int) * n);
	for(i = 0; i < n; i++)
		q[i] = i;

	// qsort
	// сортирует массив, лежащий по адресу q, имеющий n элементов, каждый размером с int,
	// и comp - это функция сравнивающая 2 элемента, и возвращающая значение >0, если первый элемент больше второго и т.д. 
	qsort (q, n, sizeof(int), (int(*)(const void *, const void *))comp);
	// ее объявление из библиотеки stdlib.h
	// void qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *));
	// тут "int(*compar)(const void *, const void *)" объявляется указатель на фунцию с именем compar
	// с 2мя аргументами - указателями, и возвращаемым значением типа int
	// см. man 3 qsort

	for(i = 0; i < n; i++)
		printf("%d ", q[i]);
	free(q);
	return 0;
}
