#include <stdio.h>
#define N 100 // важно выносить "магические" константы виде макросов

// ЦИКЛЫ
void cycles_examples(){
	int i, x;
	// for(задать начальное значение счетчика; условие - пока оно выполнено цикл работает; шаг изменения счетчика){тело цикла}
	// for(;;) - безусловный "бесконечный" цикл
	// while(условие){тело цикла}
	// do{тело цикла}while(условие) - тело цикла выполнится по меньшей мере один раз
	// while(1) - "бесконечный" цикл
	// break; - чтобы выйти из цикла

	// если надо выполнить тело цикла N раз
	x = 0;
	for(i = 0; i < N; i++){
		x++;
	}
	// или
	x = 0;
	i = 0;
	while(i < N){
		x++;
		i++;
	}

	// если нужно просто проверять условие
	x = 0;
	while (x < N) { // условие - пока оно выполнено цикл работает;
		x++;
	}
	// или
	x = 0;
	for(; x < N;){
		x++;
	}
	// Но! лучше, конечно, сделать for(x = 0; x < N; x++){}

	// завершение цикла с break;
	x = 0;
	while(1){ // или for(;;){
		x++;
		if (x >= N) // Но! если условие можно проверять в while, то надо делать это там
			break; // чтобы выйти из цикла
	}

	return;
}

// КАК СЧИТЫВАТЬ В ЦИКЛЕ
int while_getchar_sum_example(){
	int c, x = 0;
	while((c = getchar()) != '\n'){ // обратите внимание на порядок операций - скобки важны
		if ((c>='0') && (c<='9')) // проверить, что ввели цифру
			x = x + c-'0'; // с-'0' - получить не код символа обозначающего цифру, а саму цифру
		else
			printf("Error - not digit\n");
	}
	return x;
}

// БИНАРНЫЕ ОПЕРАЦИИ
void binary_example(){
	int x = 3, y = 5, z;

	z = x & y; // AND	// 0011 & 0101 = 0001
	z = x | y; // OR	// 0011 | 0101 = 0111
	z = x ^ y; // XOR	// 0011 ^ 0101 = 0110

	z = x & 0x00000004; // применить маску, чтобы вычленить 3й с конца бит числа x // т.к. 0x4 = 0100 - бинарное

	z = x >> 1; // 0011 -> 0001 // сдвиг вправо на 2 позиции, как бы деление на 2 в степени 1 
	z = x << 2; // 0011 -> 1100 // сдвиг влево на 2 позиции,  как бы умножение на 2 в степени 2

	x = 1;					// 0x00 00 00 01	// 0...0 0000 0001 - если в бинарном виде
	z = ~x; // отрицание	// 0xff ff ff fe	// 1...1 1111 1110 - если в бинарном виде

	return;
}

// КАК ПОДСЧИТАТЬ КОЛИЧЕСТВО ЕДИНИЦ В БИНАРНОЙ ЗАПИСИ ПОЛОЖИТЕЛЬНОГО ЧИСЛА
int count_number_of_1(int x){
	int number_of_1 = 0;

	// способ 1
	while(x > 0){
		number_of_1 = number_of_1 + (x & 0x01); // взять младший бит и прибавить его значение к number_of_1
		x = x >> 1; // сдвиг, чтобы проверить следующий бит
	}

	// способ 2
	for(; x > 0; x = x & (x-1)){
	// не указываем счетчик, т.к. начальное значение x уже задано
	// работаем до тех пор пока x не станет 0
	// при переходе на следующую итерацию меняем значение x по формуле x = x & (x-1)
	// x & (x-1) - обнуляет младший единичный бит числа x
	// например, если x = 0011, то x & (x-1) = 0011 & 0010 = 0010
	// например, если x = 1100, то x & (x-1) = 1100 & 1011 = 1000
		number_of_1++; // просто подсчитаем, сколько раз произошло обнуление
	}

	return number_of_1;
}

int main(){

	cycles_examples();

	printf("Sum = %d\n", while_getchar_sum_example());

	binary_example();

	int x;
	scanf("%d", &x);
	printf("number_of_1 = %d\n", count_number_of_1(x));
	return 0;
}
