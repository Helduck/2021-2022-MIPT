// arrays
int arr[100]; // чтобы создать статический массив из 100 последовательных элементов, каждый из которых имеет тип int
// таким образом можно создать массив как глобально, так и локально
// Этот массив - статический. Это важно, т.к. его размер должен быть известен на этапе компиляции

// Например,
/* делать вот так - НЕЛЬЗЯ (в чистом Си)
int n;
scanf("%d", &n);
int arr[n]; // в чистом Си это ОШИБКА - попытка создать статический массив неизвестной длины
// и ошибка тут в том, что длина массива должна быть известна компилятору заранее, т.е. задолго до запуска программы и ввода пользователем какого-либо значения
*/


// создать массив можно 2мя способами:
// 1) как статический массив
#define N 100 // N - это макроопределение, то есть вместо N везде в коде будет подставлено 100, и длина массива известна заранее
int main(){
    int arr[N];
	// а обращаться к его элементам как
    arr[0] = 0;
	// Нумерация в массиве начинается с 0. То есть, в массиве есть элементы с номерами от 0 до 99 в данном случае.
	// пройти по всем элементам массива
    for(int i=0; i<N; i++) {
    	arr[i] = i;
    	printf("%d ", arr[i]);
    }
	return 0;
}


// 2) как динамический массив
// для этого понадобится библиотека
#include<stdlib.h>
int main(){
	int n;
	scanf("%d", &n);
	if (n <= 0)
	    return 0;
	// динамически выделить память под массив
	int *p = (int *) malloc ( n * sizeof(int));
	// и обращаться к его элементам как
	p[0] = 0;
	printf("%d", p[0]);
	// не забыть потом освободить память
	free(p);
	return 0;
}


//пример нахождения максимального элемента в массиве
#include<stdio.h>
#define N 10
int main(){
	int arr[N] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, i, max; // как-нибудь заполнить массив
	max = arr[0]; // чтобы максимальный элемент гарантировано принадлежал массиву
	for(i = 0; i < N; i++) { // пройти по всем элементам
		if (max < arr[i])
			max = arr[i];
	}
	printf("%d\n", max);
	return 0;
}


// можно задавать значения элементов массива при его создании, например
int arr[N] = {0}; // обнулить все элементы
int arr[N] = {1}; // нулевой элемент будет =1, остальные при этом не изменяются
int arr[N] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // задать значение первым 10 элементам
char str1[] = "hello\0";


// адрес массива можно получить, или используя его имя
//	arr
// или, честно взяв адрес первого элемента
//	&arr[0]


// примеры функций работающих с массивами
#include <stdio.h>
#include <string.h>
#define N 5
int main(){
	char src[N] = {'1', '2', '3', '4', '5'}, dest[N] = {0}; // в src заполняем первые 5 элементов, зануляем весь dest
	int i;
	for(i = 0; i < N; i++)
		printf("%d", dest[i]); // проверим, что dest весь заполнен нулями, для этого печатаем значения элементов как числа
	printf("\n");
	
	// если надо скопировать содержимое одной области памяти (не обязательно массива) в другую
	memcpy(dest, src, N);
	// скопировать в кусок памяти, лежащий по адресу dest,
	// из куска памяти, лежащего по адресу src,
	// количество байт равное 3-му аргументу функции, т.е. в данном случае N
	// обязательно надо проверять соответствие размеров, чтобы не скопировать слишком мало, и чтобы не выйти за границы ни одного из массивов (областей памяти)

	for(i = 0; i < N; i++)
		printf("%c", dest[i]); // опять распечатаем массив, чтобы проверить, что копирование произошло (печатаем как символы)
	printf("\n");
	
	memset(dest, 'J', sizeof(dest));
	// начиная с адреса dest заполнить sizeof(dest) байт символами 'J'
	
	for(i = 0; i < N; i++)
		printf("%c", dest[i]); // опять распечатаем массив, чтобы проверить, что заполнение произошло (печатаем как символы)
	printf("\n");
	
	
	// сравнить первые 4 байта из 2х областей памяти (например, строк)
	if (memcmp(dest, "JJJJ", 4) == 0) {
		printf("First 4 bytes are equal\n");
	}
	
	return 0;
}


// strings
// строка - это массив символов, обязательно заканчивающийся символом '\0' - конец строки

// примеры использования
#include <stdio.h>
#include <string.h>
#define N 20
int main(){
	char str1[] = "hello world\0"; 
	char str2[N] = {0}; // обнулили все элементы
	int i;
	
	// примеры считывания и печати
	printf("%s\n", str1); // %s - распечатать строку, (будет распечатать пока не встретит \0)
	
	scanf("%s", str2); // %s - считать строку (до ближайшего пробела, перевода строки \n или конца строки \0)
	//scanf("%s[^\n]", str2); // %[^\n] - считать как строку - до ближайшего \n
	//scanf("%19s", str2); // %19s - считать первые 19 символов - это удобно, т.к. ввод гарантировано поместится в выделенный участок памяти из 20 байт (19 введенных + 1 '\0')
    printf("%s\n", str2);

    // примеры использования функций
    // определить длину строки (\0 не считается)
	size_t a = strlen(str1);
	printf("%ld\n", a);
	
	// скопировать строку str1 в строку str2
	if (a < N) // надо обязательно заранее проверить, что места достаточно
    	strcpy(str2, str1);
    printf("%s\n", str2);
    
    // найти подстроку в строке, возвращает указатель на начало подстроки
    char * p = strstr(str2, "wor"); 
    printf("%s\n", p);

    // сравнить 2 строки
    int b = strcmp(str1, str2);
    if (b == 0)
        printf("equal");
    if (b < 0)
        printf("str1 < str2");
	return 0;
}
