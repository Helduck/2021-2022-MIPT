/////////////////////////////////////////////////////////////////////////////////
// Указатели

// Указатель можно рассматривать как ячейку памяти, которая хранит в себе адрес переменной. Мы можем обращаться к переменной (или просто к области памяти), зная ее адрес.

// Пример
int x = 7;	// создали переменную x, т.е. выделили под нее память (4 байта) и записали в нее какое-то значение
int * p;	// создали переменную p, которая может потом служить указателем на некую переменную типа int
p = &x;		// записали в переменную p адрес переменной х. Теперь, можно сказать, что p - указатель на x.
*p = 8;		// "разыменование указателя": берем адрес из p, проходим по нему (попадаем в x) и записываем 8
// в итоге в переменной x будет лежать 8
// размер указателя, sizeof(p), стандартный и зависит от архитектуры процессора и ОС (в 64-битных системах - 8 байт)

// Типы
// указатель декларируется как:
тип_того,_на_что_он_должен_указывать * имя;
// или
void * имя;	// если не известен размер переменной, адрес которой лежит в указателе

// & и *
&x - позволяет получить адрес переменной x
*p - позволяет обратиться (прочитать или записать что-то) по адресу, который записан в p


/////////////////////////////////////////////////////////////////////////////////
// Можно делать указатели на указатели
int func(){
	// выделить память под переменные (в данном случае, это локальные переменные функции, и память под них выделяется на стеке)
	int a;
	int * b;
	int ** c;
	int *** d;
	
	// создать связи
	b = &a;		// теперь b - указатель на a (т.е., хранит адрес a)
	c = &b;		// теперь c - указатель на b (указатель на указатель на a)
	d = &c;		// теперь d - указатель на d
	
	// обратиться к a, используя d
	
	***d = 0;	// в итоге в a будет записан 0
	
	// выражение ***d разбирается справа налево: ***d = **(*d) = **c = *(*c) = *b = a
	
	return 0;
}





/////////////////////////////////////////////////////////////////////////////////
// Еще раз про динамическое выделение памяти
// Пример динамического выделения памяти под строку
#include<stdio.h>
#include<stdlib.h>

int main(){
	int m, i;
	scanf("%d", &m);
	char *p = (char*)malloc(m);		// выделить память, ровно m байт
	// или лучше char *p = (char*)malloc(sizeof(char) * m);	
	if (p == NULL)		// если ф-ция в принципе может вернуть ошибку, надо делать проверку ошибок
		printf("ERROR");
	/*
		Вызвали ф-цию malloc из библиотеки stdlib.h,
		malloc(m) выделит непрерывный кусок памяти размером m байт, и вернет указатель на него.
		malloc возвращает указатель типа void*, т.е., не знает как эта память будет использоваться
		в дальнейшем.
		Поэтому, нужно сделать приведение типов (char*) перед использованием (например, присваиванием).
		Это позволит потом обращаться к элементам массива как p[i]
	*/
	for(i = 0; i < m-1; i++) {
		p[i] = getchar();		// заполняем массив любым способом
	}
	p[m-1] = '\0'; // если хотим использовать как строку, нужно поставить символ конца строки в конце
	
	printf("%s", p);    // распечатать строку, лежащую по адресу p
	
	free(p);	// обязательно необходимо освободить память после
	
	return 0;
}




/////////////////////////////////////////////////////////////////////////////////
// Двумерные массивы

/////////////////////////////////////////////////////////////////////////////////
// Статический массив задавался бы так:
int arr[3][4];
// а обращались бы, например, так:
arr[i][j]
// то есть
for (i = 0; i < 3; i++)
	for (j = 0; j < 4; j++)
		arr[i][j] = 0;


/////////////////////////////////////////////////////////////////////////////////
// Выделить память под динамический двумерный массив можно, например, единым куском
// как бы вытягиваем все строки в одну и, на самом деле, делаем его одномерным
// 
#include<stdio.h>
#include<stdlib.h>

int main(){
	int m, n, i, j;
	scanf("%d%d", &m, &n);	// определить желаемый размер

	int *p = (int *)malloc(sizeof(int) * m * n);	// выделить память
	if (p == NULL)		// проверка ошибок
		printf("ERROR");

	// обратиться к элементу внутри массива, на строке 2 столбце 3
	p[2 * m + 3] = 0;

	// например
	for(i = 0; i < m; i++)
		for(j = 0; j < n; j++)
			p[i * m + j] = j;
	// но можно и
	for(i = 0; i < m*n; i++)
		p[i] = 0;

	free(p);	// обязательно освободить память
	return 0;
}







/////////////////////////////////////////////////////////////////////////////////
// Выделить память под динамический двумерный массив можно, например, как массив отдельных строк
// В этом случае участки памяти обозначающие разные строки (или столбцы, как посмотреть)
// могут быть выделены в разных местах
#include<stdio.h>
#include<stdlib.h>

int main(){
	int m, n, i, j;
	scanf("%d%d", &m, &n);	// определить желаемый размер

	// сначала выделим память под массив указателей, которые будут 
	// хранить адреса массивов, в которых уже будут данные
	
	int ** q = (int **) malloc(sizeof(int *) * m);	// выделить память
	if (q == NULL) {		// проверка ошибок и выход
		printf("ERROR");
		return 0;
	}
	
	// для каждой строки выделить свой кусочек памяти
	for(i = 0; i < m; i++) {
		q[i] = (int *) malloc(sizeof(int) * n);
			if (q == NULL) {		// проверка ошибок, освобождение выделенной памяти и выход
				printf("ERROR");
				for(j = 0; j < i; j++)	// т.к. до итерации i память выделялась успешно
					free(q[j]);
				free(q);	
				return 0;
			}
	}

	// обратиться к элементу внутри массива
	for(i = 0; i < m; i++)
		for(j = 0; j < n; j++)
			q[i][j] = 0;

	// обязательно освободить каждый участок памяти
	for(i = 0; i < m; i++)
		free(q[i]);
	free(q);		// этот освобождаем последним, иначе потеряются указатели на все остальные
	
	return 0;
}
